# TET-002  
## Consensus Protocol (Ripple-Style BFT Variant)  
**Status:** Draft v1.0  
**Category:** Core Foundation  

---

# 1. Purpose

This document specifies the Tetcore consensus protocol.

Tetcore uses a Ripple-style Byzantine Fault Tolerant (BFT) consensus variant with deterministic state machine replication.

The protocol ensures:

- Safety (no divergent finalized states)
- Liveness (progress under bounded fault assumptions)
- Deterministic finality (no probabilistic confirmations)

This specification is normative.

---

# 2. System Model

Let:

V = {v₁, v₂, …, vₙ} be the validator set  
n = |V|  

The network operates under partial synchrony:

- Messages may be delayed but are eventually delivered.
- Clocks are not assumed synchronized.
- Network partitions may occur but must resolve for liveness.

Fault model: Byzantine.

A faulty validator may:

- Send conflicting messages
- Remain silent
- Propose invalid blocks
- Attempt equivocation

---

# 3. Validator Sets

---

## 3.1 Active Validator Set

At any height h:

V_h ⊆ Accounts

The validator set is stored in consensus state and may change via governance.

Validators must:

- Stake required collateral
- Maintain network connectivity
- Produce and validate proposals

---

## 3.2 Unique Node List (UNL) Model

Each validator maintains a trusted validator list UNL.

Safety requires sufficient overlap among UNLs.

Let:

UNL_i be validator i’s trusted list.

Safety condition:

For any two honest validators i and j:

|UNL_i ∩ UNL_j| ≥ threshold_overlap

Overlap must be large enough to prevent conflicting quorum formation.

---

# 4. Quorum Thresholds

Let:

n = number of validators in active set.

Define quorum threshold q as:

q = ⌈0.8n⌉   (default configuration)

The protocol may support configurable threshold in range:

0.67n ≤ q ≤ 0.9n

Safety requires:

Number of Byzantine validators f < (n - q)

---

## 4.1 Safety Condition

No two conflicting blocks may both achieve quorum.

Formally:

If Block A and Block B conflict,
and A achieves q signatures,
then B cannot achieve q signatures
unless safety assumptions are violated.

---

# 5. Consensus Phases

Each consensus round proceeds in phases:

1. Proposal Phase
2. Voting Phase
3. Validation Phase
4. Finalization Phase

---

# 6. Message Types

---

## 6.1 Proposal Message

Contains:

- Proposed block hash
- Previous ledger hash
- Round number
- Validator signature

---

## 6.2 Vote Message

Contains:

- Candidate block hash
- Round number
- Signature

---

## 6.3 Validation Message

Contains:

- Finalized block hash
- State root
- Height
- Signature

---

# 7. Consensus Flow

---

## 7.1 Proposal Phase

Each validator:

- Collects pending transactions
- Constructs candidate block
- Broadcasts Proposal

---

## 7.2 Voting Phase

Validators:

- Collect proposals
- Vote on preferred candidate
- Broadcast Vote message

If vote count for block ≥ threshold (e.g., 50%), proceed.

Voting thresholds may increase across rounds.

---

## 7.3 Supermajority Phase

If block receives ≥ q votes:

- Broadcast validation message
- Lock on candidate

Validators do not vote for conflicting blocks after locking.

---

## 7.4 Finalization

When ≥ q validation messages received:

- Block finalized
- State transition B(S, Block) executed
- Ledger advanced

Finality is deterministic and immediate.

No forks permitted under honest-majority assumptions.

---

# 8. Locking Mechanism

Once a validator locks on block A:

It may only unlock if:

- A fails to reach quorum
- Or round timeout triggers escalation

Locking prevents equivocation and ensures safety.

---

# 9. Liveness

Under assumptions:

- f < (n - q)
- Eventual message delivery
- Honest majority online

Then:

The protocol guarantees block finalization within finite rounds.

Timeouts escalate vote thresholds until convergence.

---

# 10. Safety Proof Sketch

Assume:

Two conflicting blocks A and B both finalize.

Then:

Each must have ≥ q validators.

Let:

f = Byzantine validators.

For both A and B to finalize:

At least (2q - n) validators must have signed both.

Given:

q > 0.67n

Then:

2q - n > 0

Thus at least one honest validator must have signed both,
which violates locking rules.

Contradiction.

Therefore, conflicting finalization is impossible under fault bounds.

---

# 11. Fault Assumptions

Safety holds if:

f < n - q

With default q = 0.8n:

f < 0.2n

Liveness requires:

Majority of honest validators online and connected.

---

# 12. Validator Misbehavior

Detectable misbehavior:

- Double-signing
- Conflicting validations
- Invalid block proposals

Penalties may include:

- Slashing
- Validator removal
- Governance-triggered exclusion

---

# 13. View Change & Round Escalation

If no quorum achieved within timeout:

- Round number increments
- Voting thresholds increase
- New proposals allowed

Timeouts must be deterministic per round height.

---

# 14. Ledger Continuity

Each block references:

- Previous state root
- Previous block hash

Chain is strictly linear.

No probabilistic reorgs permitted.

---

# 15. Minimal Validator Requirements

Validators must:

- Maintain full state
- Verify all transactions
- Execute deterministic state machine
- Sign only canonical blocks

Light validators are not permitted in consensus-critical role.

---

# 16. Consensus Safety Boundary

Consensus layer does NOT:

- Execute contracts
- Validate inference correctness
- Validate off-chain computations

Consensus only validates deterministic state transitions.

---

# 17. Deterministic Finality Guarantee

Once block is finalized:

It cannot be reverted without violating quorum assumptions.

Tetcore provides strong finality, not probabilistic finality.

---

# 18. Conclusion

The Tetcore BFT protocol:

- Provides deterministic finality
- Tolerates Byzantine faults
- Prevents forks under defined assumptions
- Separates consensus from execution
- Supports governance-driven validator changes

This protocol forms the safety foundation for all higher-layer modules.

---

End of TET-002.