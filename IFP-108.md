# IFP-108  
## Privacy & Commitment Specification  
**Status:** Draft v1.0  
**Category:** Intelligence Fabric Protocol  

---

# 1. Purpose

This specification defines the privacy and commitment model for inference in the Intelligence Fabric Protocol (IFP).

It governs:

- Prompt commitment construction
- Salt generation and handling
- Replay resistance
- On-chain privacy guarantees
- Local-only data storage rules

This document ensures that inference payloads remain confidential while enabling deterministic economic settlement.

---

# 2. Privacy Design Principles

The protocol enforces:

- No plaintext prompt storage on-chain
- Commitment-only recording
- Salt-based protection against dictionary attacks
- Strict replay protection via transaction rules

Privacy is achieved cryptographically, not procedurally.

---

# 3. Prompt Hashing Rules

---

## 3.1 Commitment Formula

Prompt commitment must be constructed as:

prompt_commitment = SHA256(prompt_bytes || salt)

Where:

- prompt_bytes = exact byte representation of input
- salt = cryptographically secure random bytes

---

## 3.2 Encoding Requirements

Before hashing:

- prompt_bytes must use canonical encoding
- No whitespace normalization unless explicitly defined by client
- Encoding must be deterministic (e.g., UTF-8)

Hash must be exactly 32 bytes (SHA-256).

---

## 3.3 Commitment Binding

SubmitPrompt stores only:

prompt_commitment

The plaintext prompt must never appear in:

- Transaction payload
- Event logs
- State storage
- Receipt payload

---

# 4. Salt Handling

---

## 4.1 Salt Requirements

Salt must:

- Be randomly generated
- Be ≥ 16 bytes
- Be unique per prompt
- Not be reused across prompts

Recommended length: 32 bytes.

---

## 4.2 Salt Storage

Salt must be stored:

- Locally by client
- Not transmitted on-chain
- Not included in receipt payload

Loss of salt prevents future proof of original prompt.

---

## 4.3 Salt Security

Salt protects against:

- Dictionary attacks
- Rainbow table attacks
- Prompt content inference

Without salt, commitment may be brute-forced if prompt predictable.

---

# 5. Output Commitment

Operators must commit to output similarly:

output_commitment = SHA256(output_bytes || output_salt)

output_salt:

- Generated per inference
- Retained locally by operator or shared securely with client

Output plaintext must not appear on-chain.

---

# 6. Replay Protection

Replay protection is enforced through:

- Account nonce (TET-003)
- chain_id inclusion
- Unique prompt_tx_hash

---

## 6.1 Nonce Rule

Each SubmitPrompt must include:

nonce = previous_nonce + 1

Replayed transaction with old nonce will be rejected.

---

## 6.2 Chain Isolation

Commitment includes chain context implicitly via transaction hash.

Transaction signed with specific chain_id prevents cross-network replay.

---

## 6.3 Duplicate Commitment Rule

Protocol does NOT forbid identical prompt_commitment across different transactions.

However:

Nonce and escrow ensure each instance is economically distinct.

---

# 7. Local-Only Storage Guarantees

---

## 7.1 On-Chain Restrictions

Protocol MUST NOT store:

- Plaintext prompt
- Plaintext output
- Salt
- Encryption keys

Only commitment hashes allowed.

---

## 7.2 Client Responsibility

Client must store locally:

- prompt_bytes
- salt
- optional output_bytes
- output_salt

Protocol does not provide recovery if lost.

---

## 7.3 Operator Responsibility

Operators may store:

- prompt ciphertext
- output plaintext
- execution logs

Protocol does not require retention.

---

# 8. Dispute Proof Potential

In dispute scenarios, client may reveal:

prompt_bytes + salt

To prove:

SHA256(prompt || salt) == prompt_commitment

Future protocol versions may define formal dispute mechanism.

---

# 9. Metadata Privacy

Transport metadata must not leak:

- Prompt plaintext
- Output plaintext
- Sensitive user identifiers

Allowed metadata limited to:

- model_id
- version
- prompt_tx_hash
- routing flags

---

# 10. Determinism Boundary

Privacy mechanisms must:

- Not alter deterministic state transitions
- Not introduce randomness into consensus logic
- Remain entirely off-chain except commitment hash

All hashing is deterministic.

---

# 11. Security Assumptions

Privacy depends on:

- SHA-256 collision resistance
- Proper salt randomness
- Secure encryption transport (IFP-107)
- Secure key management by clients

Protocol does not guarantee privacy if:

- Client reuses salt
- Prompt is trivial and predictable
- Local machine compromised

---

# 12. Commitment Immutability

Once prompt_commitment recorded:

It is immutable.

Protocol does not allow updating commitment for same prompt_tx_hash.

---

# 13. Attack Resistance

The commitment scheme resists:

- Prompt guessing (with proper salt)
- Hash collision attacks (under SHA-256 assumptions)
- Cross-chain replay
- Nonce replay

---

# 14. Future Extensions

Possible enhancements:

- ZK proof of prompt structure
- Encrypted prompt escrow channels
- Private mempool submission
- Confidential transaction wrappers

All must preserve deterministic state roots.

---

# 15. Formal Model

Let:

C = SHA256(P || S)

Where:

P = prompt_bytes  
S = salt  

Protocol stores C only.

If client later reveals P, S:

Verification:

SHA256(P || S) == C

---

# 16. Invariants

For every SubmitPrompt:

- prompt_commitment is 32 bytes
- salt length ≥ 16 bytes (off-chain rule)
- No plaintext stored on-chain
- Nonce strictly increasing

---

# 17. Conclusion

IFP-108 ensures:

- Prompt confidentiality
- Commitment integrity
- Salt-based security
- Deterministic replay protection
- Strict local-only plaintext storage

It preserves user privacy while enabling:

Escrow enforcement  
Economic settlement  
Protocol-level inference accounting  

Without exposing sensitive data to the ledger.

---

End of IFP-108.