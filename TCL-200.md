# TCL-200  
## Tetcore Contract Language (TCL) Specification  
**Status:** Draft v1.0  
**Category:** Tetcore Virtual Machine Layer  

---

# 1. Purpose

This specification defines the Tetcore Contract Language (TCL), the deterministic smart contract language executed by the Tetcore Virtual Machine (TVM).

TCL is designed to be:

- Deterministic
- Capability-secure
- Integer-only
- Resource-metered
- Fully reproducible across nodes

TCL contracts execute inside the Tetcore state transition function.

---

# 2. Design Principles

TCL must:

- Prohibit floating-point arithmetic
- Avoid nondeterministic behavior
- Enforce capability-based access control
- Guarantee atomic state commits
- Enforce strict gas accounting
- Be statically analyzable

TCL is not Turing-infinite by default; recursion and loops are bounded by gas.

---

# 3. Execution Model

Contract execution occurs during:

Δ(S, Tx)

All TCL code must:

- Produce deterministic output
- Consume bounded gas
- Commit state changes atomically
- Revert fully on failure

Execution must not:

- Perform network IO
- Perform file IO
- Access system time
- Use randomness without deterministic seed

---

# 4. Syntax

TCL uses a structured, Rust-inspired syntax.

---

## 4.1 Basic Structure

```
contract MyContract {

    storage {
        counter: u64;
        owner: Address;
    }

    fn init(ctx: Context) {
        self.owner = ctx.sender;
        self.counter = 0;
    }

    fn increment(ctx: Context) {
        require(ctx.sender == self.owner);
        self.counter = self.counter + 1;
    }
}
```

---

## 4.2 Core Elements

- contract declaration
- storage block
- function definitions
- require(condition)
- return statement

---

# 5. Type System

---

## 5.1 Primitive Types

Allowed primitive types:

- u8, u16, u32, u64, u128
- i64 (optional)
- bool
- Address
- Hash32
- Bytes (bounded)
- String (bounded UTF-8)

---

## 5.2 Composite Types

- struct
- fixed-size arrays
- bounded vectors
- mapping<Key, Value>

Mappings must use deterministic key hashing.

---

## 5.3 Forbidden Types

- Floating-point types
- Unbounded recursion types
- Dynamic unbounded memory types

---

# 6. Determinism Constraints

---

## 6.1 No Floating Point

All arithmetic must use integer types.

Overflow behavior must be:

Checked arithmetic → revert on overflow.

---

## 6.2 No Wall Clock

Contracts must not access:

- Block timestamp directly (unless provided deterministically)
- System time
- Timezone data

Only allowed time reference:

ctx.block_height

---

## 6.3 No Randomness

Randomness only allowed via:

Deterministic seed derived from:

- Previous block hash
- Explicit input

Non-deterministic RNG prohibited.

---

## 6.4 No External Calls

Contracts may call:

- Other contracts
- Kernel-defined functions

Must not:

- Perform external HTTP calls
- Open sockets
- Access host filesystem

---

# 7. Capability Model

---

## 7.1 Principle

TCL uses capability-based security.

Contracts may only access:

- Their own storage
- Explicitly granted capabilities
- Kernel-defined APIs

---

## 7.2 Capability Types

Examples:

- TransferCapability
- StakeCapability
- VaultModifyCapability
- GovernanceProposalCapability

Capabilities must be explicitly passed or granted.

---

## 7.3 Access Control

Common pattern:

```
require(ctx.sender == self.owner);
```

Or capability check:

```
require(ctx.has_capability(VaultModifyCapability));
```

---

# 8. Storage Model

---

## 8.1 Storage Scope

Each contract has:

Isolated storage namespace.

Storage defined in:

storage { }

---

## 8.2 Storage Access

Access via:

self.variable_name

Mapping access:

self.mapping[key]

---

## 8.3 Commit Rules

All storage writes:

- Occur in execution sandbox
- Commit only if function completes successfully
- Revert fully on failure

---

## 8.4 Storage Cost

Each storage write consumes gas:

gas += STORAGE_WRITE_COST

Gas cost defined in gas schedule.

---

# 9. Gas Model

---

## 9.1 Gas Units

Every operation has fixed gas cost.

Gas must be:

- Deterministic
- Predefined
- Governance-adjustable

---

## 9.2 Gas Limits

Each ContractCall transaction defines:

gas_limit

If gas_used > gas_limit:

Execution halts and reverts.

---

## 9.3 Deterministic Metering

Gas accounting must not depend on:

- CPU performance
- Memory allocation time
- Thread scheduling

---

# 10. Memory Model

---

## 10.1 Stack

Execution stack must:

- Have bounded depth
- Use fixed maximum stack size

---

## 10.2 Heap

Heap allocations must:

- Be bounded
- Metered
- Deterministic

---

# 11. Contract Calls

---

## 11.1 Internal Call

Contract A may call Contract B:

call B.function(args)

Gas passed explicitly.

---

## 11.2 Reentrancy Rules

Reentrancy is permitted but:

- State updates must follow checks-effects-interactions pattern
- Gas metering applies across nested calls

Optional reentrancy guard recommended.

---

# 12. Error Handling

Errors must be:

- Deterministic
- Explicit
- Coded as defined error codes

Example:

revert(ErrorCode::Unauthorized);

---

# 13. Events

Contracts may emit:

event EventName { fields }

Events:

- Recorded in block log
- Not part of consensus state
- Must not affect execution logic

---

# 14. Versioning

Contracts include:

contract_version: u32

Upgrade mechanisms must be defined via governance or proxy pattern.

Upgrades must preserve deterministic behavior.

---

# 15. Formal Execution Model

Let:

Execute(S, ContractCallTx) → S'

Where:

- S = previous state
- Gas deducted
- Storage updated
- All deterministic constraints applied

If error:

S' = S (except gas consumed)

---

# 16. Security Guarantees

TCL ensures:

- Deterministic execution
- No floating point drift
- Bounded memory
- Gas-bounded execution
- Capability-based isolation

It does NOT ensure:

- Formal correctness
- Absence of logical bugs
- Economic soundness of contract design

---

# 17. Implementation Constraints

TVM implementations must:

- Use fixed byte ordering
- Avoid undefined behavior
- Disable host-language floating point
- Pass deterministic test vectors

---

# 18. Future Extensions

Potential future features:

- Formal verification annotations
- ZK-friendly bytecode
- Contract-level privacy
- Deterministic randomness beacons

All extensions must preserve:

Integer arithmetic  
Gas determinism  
State reproducibility  

---

# 19. Conclusion

TCL defines a:

- Deterministic
- Integer-only
- Capability-secured
- Gas-metered
- State-isolated

Smart contract language for Tetcore.

It enables programmable intelligence infrastructure without sacrificing consensus safety.

---

End of TCL-200.