# TET-004  
## Transaction Format Specification  
**Status:** Draft v1.0  
**Category:** Core Foundation  

---

# 1. Purpose

This specification defines the canonical transaction format for Tetcore.

It standardizes:

- Transaction envelope structure  
- Deterministic serialization rules  
- Type-specific payload formats  
- Validation requirements  

All compliant implementations MUST encode and decode transactions identically.

---

# 2. Canonical Transaction Envelope

Every transaction has the following envelope:

Tx = {
  version: u8,
  chain_id: u32,
  type: u16,
  sender: Address,
  nonce: u64,
  fee_limit: u128,
  gas_limit: u64,
  payload: Bytes,
  signature: Bytes
}

---

## 2.1 Field Definitions

version  
Protocol version identifier.

chain_id  
Prevents cross-chain replay.

type  
Transaction type identifier.

sender  
32-byte canonical address.

nonce  
Strictly increasing per account.

fee_limit  
Maximum tokens allowed to be deducted.

gas_limit  
Maximum gas units allowed.

payload  
Type-specific structured data.

signature  
Ed25519 signature over canonical encoding of all fields except signature.

---

# 3. Canonical Encoding Rules

---

## 3.1 Serialization Requirements

- Big-endian integer encoding
- Fixed-width integers
- Deterministic field ordering
- No floating point values
- Length-prefixed byte arrays

---

## 3.2 Signing Hash

Signing input:

hash = SHA256(CanonicalEncode(
  version,
  chain_id,
  type,
  sender,
  nonce,
  fee_limit,
  gas_limit,
  payload
))

Signature must be appended after hash generation.

---

# 4. Transaction Type Identifiers

| Type ID | Name |
|----------|------|
| 0x0001 | SubmitPrompt |
| 0x0002 | SubmitReceipt |
| 0x0003 | RegisterModel |
| 0x0004 | Stake |
| 0x0005 | GovernanceProposal |
| 0x0006 | ContractCall |

---

# 5. SubmitPrompt Transaction

---

## 5.1 Purpose

Registers an inference request on-chain.

---

## 5.2 Payload Structure

SubmitPromptPayload = {
  model_id: Hash32,
  prompt_commitment: Hash32,
  max_output_tokens: u32,
  pricing_mode: u8,
  relay_mode: u8,
  deadline_height: u64
}

---

## 5.3 Field Semantics

model_id  
Identifier of registered model.

prompt_commitment  
SHA256(prompt || salt).

max_output_tokens  
Upper bound for generation.

pricing_mode  
0 = owner  
1 = market  
2 = hybrid  

relay_mode  
0 = relay delivery  
1 = direct delivery  

deadline_height  
Block height after which receipt invalid.

---

# 6. SubmitReceipt Transaction

---

## 6.1 Purpose

Confirms inference execution and triggers settlement.

---

## 6.2 Payload Structure

SubmitReceiptPayload = {
  prompt_tx_hash: Hash32,
  output_commitment: Hash32,
  input_tokens: u32,
  output_tokens: u32,
  compute_units: u64,
  operator_address: Address
}

---

## 6.3 Validation Rules

- prompt_tx_hash must exist
- deadline not exceeded
- receipt not already submitted
- operator must be registered
- fee must not exceed fee_limit

---

# 7. RegisterModel Transaction

---

## 7.1 Purpose

Registers a new intelligence asset.

---

## 7.2 Payload Structure

RegisterModelPayload = {
  model_id: Hash32,
  owner: Address,
  version: u32,
  shard_root: Hash32,
  pricing_policy: u8,
  revenue_split_basis_points: {
    operator: u16,
    owner: u16,
    validators: u16,
    vault: u16
  }
}

---

## 7.3 Constraints

- Sum of basis points = 10000
- model_id must not already exist
- shard_root must be valid commitment

---

# 8. Stake Transaction

---

## 8.1 Purpose

Stake tokens into model vault or validator pool.

---

## 8.2 Payload Structure

StakePayload = {
  target_type: u8,
  target_id: Hash32,
  amount: u128
}

target_type:
0 = ModelVault  
1 = Validator  

---

# 9. GovernanceProposal Transaction

---

## 9.1 Purpose

Submit proposal for governance vote.

---

## 9.2 Payload Structure

GovernanceProposalPayload = {
  proposal_type: u8,
  title_hash: Hash32,
  description_hash: Hash32,
  execution_payload: Bytes,
  voting_period: u64
}

execution_payload  
Serialized runtime modification instructions.

---

# 10. ContractCall Transaction

---

## 10.1 Purpose

Invoke a deployed TCL contract.

---

## 10.2 Payload Structure

ContractCallPayload = {
  contract_address: Address,
  method_selector: u32,
  calldata: Bytes,
  value: u128
}

value  
Optional token transfer to contract.

---

# 11. Gas Accounting

Each transaction type has:

- Base gas cost
- Payload-size dependent gas
- Execution gas
- Storage gas

Gas consumption must be deterministic.

---

# 12. Validation Order

Upon receiving transaction:

1. Verify signature
2. Verify chain_id
3. Verify nonce
4. Verify sufficient balance
5. Validate payload structure
6. Execute module dispatch

If validation fails:
Transaction rejected.

---

# 13. Determinism Requirements

Transactions must:

- Produce identical state mutation on all nodes
- Consume identical gas
- Encode identically
- Reject malformed variants

---

# 14. Backward Compatibility

version field allows future extension.

Nodes must reject unsupported version.

---

# 15. Conclusion

This specification defines:

- The canonical transaction envelope
- Deterministic encoding rules
- Type-specific payload formats
- Validation order
- Settlement triggers

All protocol logic begins with correct transaction parsing.

Violation of canonical encoding breaks consensus safety.

---

End of TET-004.