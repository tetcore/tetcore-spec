# TET-003  
## Network Identity & Cryptography Specification  
**Status:** Draft v1.0  
**Category:** Core Foundation  

---

# 1. Purpose

This specification defines the cryptographic identity model for Tetcore.

It governs:

- Key generation
- Address derivation
- Transaction signing
- Signature verification
- Replay protection

All nodes MUST implement this specification identically.

---

# 2. Cryptographic Primitives

---

## 2.1 Key Scheme

Tetcore uses:

Ed25519 (EdDSA over Curve25519)

Properties:

- Deterministic signatures
- 32-byte public keys
- 64-byte signatures
- High performance
- Strong security assumptions

Future versions MAY introduce alternative curves via governance, but Ed25519 is canonical in v1.0.

---

## 2.2 Hash Function

Tetcore uses:

SHA-256 for hashing

Used for:

- Transaction hashes
- Address derivation
- Commitment hashing
- State root construction (Merkle)

All hash inputs must be deterministically encoded.

---

# 3. Key Generation

---

## 3.1 Private Key

A private key sk is:

sk ∈ {0,1}²⁵⁶

Generated using:

- Cryptographically secure random generator
- Deterministic seed derivation (optional HD wallet support)

Private keys must never be transmitted over network.

---

## 3.2 Public Key

Public key pk is derived:

pk = Ed25519_PublicKey(sk)

pk ∈ {0,1}²⁵⁶

---

# 4. Address Derivation

Tetcore addresses are derived from public keys.

---

## 4.1 Address Format

Address = first 32 bytes of:

SHA256(pk)

Alternative canonical representation:

Address = Bech32(prefix || SHA256(pk)[0:32])

Prefix (v1.0):

"tet"

Example:

tet1xyz...

---

## 4.2 Address Properties

- 32-byte internal binary representation
- Case-insensitive Bech32 human-readable form
- Collision resistance inherited from SHA-256

Addresses are immutable once derived.

---

# 5. Transaction Signing

---

## 5.1 Signing Input

Transactions must be signed over:

hash = SHA256(CanonicalEncode(TxPayload))

Signature:

sig = Ed25519_Sign(sk, hash)

---

## 5.2 Canonical Encoding

Canonical encoding must:

- Preserve field order
- Use deterministic serialization
- Avoid floating point
- Avoid platform-dependent byte order

Failure to use canonical encoding invalidates signature.

---

# 6. Signature Verification

Upon receiving transaction Tx:

1. Extract pk
2. Derive Address
3. Compute hash
4. Verify:

Ed25519_Verify(pk, hash, sig)

If verification fails:

Transaction MUST be rejected.

---

# 7. Nonce & Replay Protection

Each account maintains:

nonce ∈ ℕ

---

## 7.1 Nonce Rule

For transaction Tx from account A:

Tx.nonce MUST equal:

State[A].nonce + 1

After successful execution:

State[A].nonce increments by 1

---

## 7.2 Replay Prevention

Replay protection mechanisms:

- Nonce enforcement
- Chain ID inclusion
- Transaction hash uniqueness

---

## 7.3 Chain ID

Each Tetcore network defines:

chain_id ∈ ℕ

Transaction signing hash includes:

chain_id

Prevents cross-network replay.

---

# 8. Validator Signatures

Validators sign:

- Proposal messages
- Vote messages
- Validation messages

Signature format identical to transaction signature.

Validator identity is bound to public key registered in state.

---

# 9. Commitment Hashing

Used in:

- Prompt commitments
- Model shard commitments
- Receipt commitments

Commitment format:

commit = SHA256(data || salt)

Salt prevents dictionary attacks.

Salt length: minimum 16 bytes.

---

# 10. Determinism Requirements

Cryptographic operations must:

- Use deterministic Ed25519 signing
- Avoid nondeterministic entropy during signature generation
- Use canonical encoding

All nodes must produce identical verification results.

---

# 11. Key Rotation

Accounts may rotate keys via:

KeyUpdate transaction:

- Signed by current key
- Updates public key
- Preserves account address OR creates new account

If preserving address:

Address must remain derived from original pk.

Alternate approach:

Key rotation creates new address and migrates funds.

Governance defines policy.

---

# 12. Slashing Evidence Signatures

If validator signs conflicting blocks:

Both signatures are cryptographic proof of misbehavior.

Evidence includes:

- Block hash A signature
- Block hash B signature
- Same height
- Same validator

Such evidence triggers penalty logic.

---

# 13. Cryptographic Security Assumptions

Security depends on:

- Ed25519 unforgeability
- SHA-256 collision resistance
- Proper randomness in key generation

Compromise of private key compromises account.

Protocol does not protect against key theft.

---

# 14. Prohibited Practices

Nodes MUST NOT:

- Accept non-canonical signature encodings
- Use alternate curve implementations
- Skip nonce verification
- Accept duplicate nonces
- Accept malformed public keys

---

# 15. Minimal Compliance Requirements

To be compliant, an implementation must:

- Implement Ed25519 per RFC 8032
- Use SHA-256 exactly
- Enforce nonce strictly
- Reject any transaction failing signature verification

---

# 16. Conclusion

Tetcore identity is:

- Deterministic
- Cryptographically secure
- Replay-resistant
- Chain-bound

This specification defines the cryptographic root of trust for:

- Transactions
- Governance
- Consensus
- Intelligence commitments

All higher-layer security depends on strict adherence to this document.

---

End of TET-003.