# TET-005  
## Multi-Ledger Architecture Specification  
**Status:** Draft v1.0  
**Category:** Core Foundation  

---

# 1. Purpose

This document defines the Tetcore multi-ledger architecture.

Tetcore separates state into distinct ledger classes to:

- Prevent unbounded state growth
- Enable prunable inference records
- Support model shard availability
- Maintain deterministic core state
- Provide checkpointed finality

This specification is normative.

---

# 2. Ledger Classes

Tetcore defines three canonical ledger types:

1. Core Ledger  
2. Model Storage Ledger  
3. Prunable Shard Ledger  

Each ledger has distinct:

- Persistence guarantees
- Retention policies
- Validation rules
- Pruning semantics

---

# 3. Core Ledger

---

## 3.1 Definition

The Core Ledger contains permanent consensus-critical state:

CoreLedger = {
  Accounts,
  Validators,
  Governance,
  Contracts,
  Models (metadata),
  Vaults,
  Economics
}

---

## 3.2 Properties

- Non-prunable
- Fully replicated by validators
- State root committed in every block
- Required for consensus safety

---

## 3.3 Storage Model

Core ledger is:

- Merkleized
- Deterministically encoded
- Checkpointed at every finalized block

---

# 4. Model Storage Ledger

---

## 4.1 Definition

Stores model metadata and shard commitments.

ModelStorageLedger = {
  model_id → {
    owner,
    version,
    shard_root,
    shard_count,
    pricing_policy,
    activation_status
  }
}

---

## 4.2 Properties

- Persistent
- Consensus-critical metadata only
- Does NOT store raw model weights
- Stores cryptographic commitments only

---

## 4.3 Update Rules

Model updates require:

- Owner authorization
- Version increment
- Governance compliance (if required)

---

# 5. Prunable Shard Ledger

---

## 5.1 Purpose

Handles temporary or large data commitments:

- Inference receipts
- Shard availability proofs
- Challenge claims

---

## 5.2 Structure

PrunableLedger = {
  entry_id → {
    commitment,
    creation_height,
    expiry_height
  }
}

---

## 5.3 Pruning Condition

An entry may be pruned if:

current_height > expiry_height
AND
challenge_window expired

---

# 6. TTL (Time-To-Live) Rules

TTL determines lifespan of non-core entries.

For entry E:

E.expiry_height = E.creation_height + ttl_blocks

ttl_blocks is defined per transaction type:

| Entry Type | TTL |
|------------|-----|
| SubmitPrompt | 10–100 blocks |
| Receipt | 100–500 blocks |
| Shard availability proof | configurable |

TTL values are governance-controlled.

---

# 7. Challenge Windows

---

## 7.1 Purpose

Allow time to dispute:

- Invalid receipts
- Missing shard availability
- Fraudulent commitments

---

## 7.2 Challenge Window Definition

challenge_window_blocks = governance parameter

Entry remains disputable until:

creation_height + challenge_window_blocks

After window closes:

Entry becomes final and prunable.

---

## 7.3 Dispute Mechanism

During challenge window:

- Proof of misbehavior may be submitted
- Slashing or penalties may apply
- Entry may be invalidated

---

# 8. State Checkpoints

---

## 8.1 Block-Level Checkpoints

Each finalized block commits:

- State root
- Block hash
- Height

Validators must store recent checkpoint history.

---

## 8.2 Epoch Checkpoints

Every N blocks:

- Create epoch checkpoint
- Snapshot state root
- Record validator set

Used for:

- Fast sync
- State verification
- Audit purposes

---

## 8.3 Checkpoint Finality

Checkpoint at height h is final if:

Block h finalized under BFT consensus.

---

# 9. Ledger Isolation Rules

Core Ledger MUST NOT reference prunable data directly.

Instead:

Core ledger stores:

- Commitment hash
- Metadata
- Expiry parameters

Actual payload data is stored off-chain or in prunable ledger.

---

# 10. Storage Responsibility

---

## 10.1 Validators

Must store:

- Full Core Ledger
- Active Model Metadata
- Active Challenge Windows

---

## 10.2 Inference Operators

May store:

- Prompt payloads (off-chain)
- Output payloads (off-chain)
- Shard fragments

---

## 10.3 Storage Nodes

May voluntarily store:

- Model shards
- Availability proofs

Economic incentives governed by IFP.

---

# 11. Pruning Safety Constraints

Pruning MUST NOT:

- Affect state root integrity
- Remove data still within challenge window
- Remove metadata required for economic settlement

Validators must verify pruning conditions deterministically.

---

# 12. Ledger Root Composition

Global state root includes:

root = Merkle(
  CoreLedgerRoot,
  ModelStorageLedgerRoot,
  ActivePrunableLedgerRoot
)

Pruned entries are removed from Merkle subtree deterministically.

---

# 13. Multi-Ledger Determinism

All pruning operations must:

- Occur at deterministic block heights
- Use deterministic criteria
- Produce identical resulting state across nodes

---

# 14. State Growth Control

Multi-ledger separation ensures:

- Core ledger remains compact
- Large inference data does not bloat consensus
- Shard commitments are constant-size

This preserves long-term scalability.

---

# 15. Fast Synchronization

New node may:

1. Download latest checkpoint
2. Download state snapshot
3. Verify state root
4. Begin processing new blocks

Prunable data older than TTL need not be downloaded.

---

# 16. Governance Control

Governance may modify:

- TTL values
- Challenge window duration
- Pruning policies
- Checkpoint interval

Changes must not retroactively invalidate finalized state.

---

# 17. Security Guarantees

Multi-ledger architecture ensures:

- Core determinism preserved
- Fraud disputable within window
- State growth bounded
- Large model assets remain off-chain

---

# 18. Conclusion

Tetcore multi-ledger architecture:

- Separates permanent and temporary data
- Supports scalable inference systems
- Enables prunable commitments
- Maintains strict determinism
- Preserves consensus integrity

It is foundational for intelligence-scale infrastructure.

---

End of TET-005.