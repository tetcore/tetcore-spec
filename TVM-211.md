# TVM-211  
## Gas Schedule & Resource Accounting  
**Status:** Draft v1.0  
**Category:** Tetcore Virtual Machine Layer  

---

# 1. Purpose

This specification defines the gas accounting and resource pricing model of the Tetcore Virtual Machine (TVM).

Gas ensures:

- Bounded execution
- Spam resistance
- Fair resource allocation
- Deterministic execution cost

All gas calculations are consensus-critical.

---

# 2. Gas Unit Definition

Gas is an abstract integer unit representing computational and storage effort.

Properties:

- Deterministic
- Architecture-independent
- Integer-based
- Governance-adjustable

Gas does NOT represent real-time or hardware cycles.

---

# 3. Execution Gas Model

For any execution:

gas_used = Σ(instruction_costs)
         + Σ(storage_costs)
         + Σ(memory_costs)
         + Σ(host_call_costs)

If gas_used > gas_limit:

Execution reverts with OutOfGas.

---

# 4. Instruction Cost Model

---

## 4.1 Fixed Cost Per Opcode

Each opcode has fixed base cost.

Example baseline schedule:

ADD       = 3  
SUB       = 3  
MUL       = 5  
DIV       = 8  
MOD       = 8  
AND       = 3  
OR        = 3  
XOR       = 3  
NOT       = 2  
SHL       = 3  
SHR       = 3  
EQ        = 3  
LT        = 3  
GT        = 3  
JMP       = 2  
JMPIF     = 3  
PUSH      = 2  
POP       = 2  
DUP       = 2  
SWAP      = 2  
RET       = 0  

Governance may modify values but must preserve determinism.

---

## 4.2 Overflow Handling

Overflow-triggered revert still consumes gas up to failure point.

No gas refund for arithmetic errors.

---

# 5. Storage Write Cost

Storage is the most expensive resource.

---

## 5.1 SLOAD Cost

SLOAD (read):

SLOAD_COST = 50

---

## 5.2 SSTORE Cost

SSTORE cost depends on state transition:

Case 1: Zero → Non-zero  
SSTORE_SET = 2000

Case 2: Non-zero → Non-zero  
SSTORE_UPDATE = 500

Case 3: Non-zero → Zero  
SSTORE_CLEAR = 2000

Optional refund model may apply for clearing.

---

## 5.3 Determinism Constraint

Storage cost must depend only on:

- Previous value
- New value

Never on:

- Disk state
- IO latency
- Node hardware

---

# 6. Memory Cost Model

---

## 6.1 Base Memory Access

MLOAD = 3  
MSTORE = 3  

---

## 6.2 Memory Expansion

Memory expansion cost computed as:

memory_words = ceil(new_memory_size / 32)

memory_cost = base_cost × memory_words

Expansion formula must be deterministic.

Example:

memory_expansion_cost =
  3 × (new_words - previous_words)

---

## 6.3 Maximum Memory

MAX_MEMORY_SIZE defined (e.g., 1 MB).

If allocation exceeds limit:

Revert.

---

# 7. Host Call Cost

Host calls are calls into kernel-defined functions.

Examples:

Transfer  
Stake  
VaultUpdate  
GovernanceAction  

---

## 7.1 Base Host Call Cost

HOST_CALL_BASE = 100

---

## 7.2 Per-Operation Cost

Host call may add additional deterministic cost based on:

- Token transfer amount (constant cost)
- Number of storage writes triggered
- Parameter size

Total cost must be predefined and deterministic.

---

# 8. Contract-to-Contract Call Cost

CCALL base cost:

CCALL_BASE = 40

Additional cost:

- Calldata length × per_byte_cost
- Gas forwarded

Nested calls must not exceed gas forwarded.

---

# 9. Event Emission Cost

Event cost:

EVENT_BASE = 20  
EVENT_PER_BYTE = 2  

Events do not modify state.

---

# 10. Gas Refund Model

Optional gas refund allowed for:

- Storage clear (Non-zero → Zero)

Refund must:

- Be capped (e.g., max 50% of total gas_used)
- Applied at end of execution
- Deterministically computed

Refund cannot exceed gas already consumed.

---

# 11. Resource Accounting Invariants

For every execution:

gas_remaining_initial = gas_limit  
gas_remaining_final ≥ 0  

gas_used = gas_limit - gas_remaining_final  

Must satisfy:

gas_used ≥ minimum_base_cost

---

# 12. Deterministic Accounting Requirements

Gas calculation must not depend on:

- CPU speed
- Memory latency
- Storage medium
- Thread scheduling

All gas costs must be constant integers.

---

# 13. DoS Resistance

Gas model prevents:

- Infinite loops (bounded by gas)
- Excessive memory allocation
- Excessive storage writes
- Excessive nested calls

Gas limits must be enforced strictly.

---

# 14. Governance Control

Governance may modify:

- Instruction costs
- Storage costs
- Memory cost formula
- Host call costs
- Refund ratios

Changes require:

- Runtime upgrade
- Version bump
- Network-wide agreement

---

# 15. Formal Gas Function

Define:

GasCost(opcode, state_transition, memory_delta, host_call) → u64

TotalGas(execution_trace) = Σ GasCost(...)

Must be identical across nodes.

---

# 16. Gas and Inference Interaction

Gas covers:

- Contract execution only

Inference fees under IFP-104 are separate from gas.

Gas prevents computational abuse of TVM.

Inference fees cover model execution economics.

---

# 17. Safety Constraints

Gas model must prevent:

- Negative gas balances
- Gas underflow
- Overflow in gas calculation
- Refund exceeding used gas

All arithmetic must use checked operations.

---

# 18. Implementation Requirements

Implementations must:

- Meter gas before execution of each opcode
- Deduct gas deterministically
- Halt execution immediately on gas exhaustion
- Record gas usage identically across platforms

---

# 19. Economic Implications

Gas enforces:

- Fair usage of execution layer
- Spam resistance
- Cost visibility
- Predictable execution budgeting

Gas is not inflationary.

Gas payments are transferred to:

Validators or burned (governance-defined).

---

# 20. Conclusion

TVM-211 defines:

- Fixed opcode costs
- Deterministic storage pricing
- Bounded memory expansion cost
- Host call metering
- Refund constraints

It ensures that contract execution remains:

Predictable  
Bounded  
Spam-resistant  
Consensus-safe  

And independent of hardware variability.

---

End of TVM-211.