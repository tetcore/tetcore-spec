# TCL-201  
## Tetcore ABI (TABI) Specification  
**Status:** Draft v1.0  
**Category:** Tetcore Virtual Machine Layer  

---

# 1. Purpose

This specification defines the Tetcore Application Binary Interface (TABI).

TABI standardizes:

- How contract calls are encoded
- How arguments are serialized
- How entry points are resolved
- How return values are formatted

TABI ensures deterministic contract invocation across all nodes.

---

# 2. Design Principles

TABI must be:

- Deterministic
- Platform-independent
- Strictly typed
- Integer-only
- Canonically encoded

TABI must avoid:

- Floating-point encoding
- Platform-dependent serialization
- Locale-sensitive string encoding

---

# 3. Canonical Encoding Rules

---

## 3.1 Byte Ordering

All numeric types must be encoded:

Big-endian

---

## 3.2 Integer Encoding

Fixed-width encoding required.

Examples:

u8  → 1 byte  
u16 → 2 bytes  
u32 → 4 bytes  
u64 → 8 bytes  
u128 → 16 bytes  

No variable-length integer encoding permitted in consensus-critical paths.

---

## 3.3 Boolean Encoding

bool:

0x00 = false  
0x01 = true  

Any other value invalid.

---

## 3.4 Address Encoding

Address must be:

Fixed 32-byte representation.

---

## 3.5 Hash32 Encoding

Exactly 32 bytes.

---

## 3.6 String Encoding

Strings encoded as:

[length: u32][UTF-8 bytes]

Constraints:

- Length ≤ MAX_STRING_SIZE
- UTF-8 only
- No normalization performed

---

## 3.7 Byte Array Encoding

Bytes encoded as:

[length: u32][raw bytes]

Length must be bounded by governance-defined maximum.

---

## 3.8 Struct Encoding

Struct fields encoded:

In declared order.

No field reordering allowed.

---

## 3.9 Array Encoding

Fixed-size arrays:

Encoded sequentially without length prefix.

Dynamic arrays:

[length: u32][elements...]

---

# 4. Function Selector

---

## 4.1 Entry Point Naming

Function name encoded as:

UTF-8 string

Function selector computed as:

selector = first_8_bytes(SHA256(contract_name || "::" || function_name))

Selector length: 8 bytes

---

## 4.2 Selector Resolution

Upon contract call:

- Selector matched to declared function
- If no match → revert

Function overloading not permitted in v1.0.

---

# 5. Contract Call Format

---

## 5.1 ContractCall Transaction Payload

ContractCallPayload = {
  contract_address: Address,
  selector: [8 bytes],
  calldata: Bytes,
  gas_limit: u64
}

---

## 5.2 Calldata Structure

calldata = ABI-encoded arguments

Arguments encoded sequentially.

Order must match function signature exactly.

---

# 6. Execution Context

Upon invocation:

Context provides:

- sender: Address
- value: u128 (if token transfer)
- block_height: u64
- gas_remaining: u64

Context fields are NOT part of ABI encoding.

---

# 7. Return Value Semantics

---

## 7.1 Success Return

Return format:

ReturnData = {
  success: 0x01,
  data: ABI-encoded return value(s)
}

---

## 7.2 Revert

On revert:

ReturnData = {
  success: 0x00,
  error_code: u32,
  error_data: optional Bytes
}

State changes revert fully.

Gas consumed up to failure retained.

---

## 7.3 Multiple Return Values

Multiple values encoded as tuple:

(value1, value2, ...)

Encoded sequentially using ABI rules.

---

# 8. Determinism Constraints

TABI must:

- Encode identically across platforms
- Reject malformed inputs deterministically
- Reject incorrect length encodings
- Reject unknown selectors

ABI decoding must not depend on:

- Host memory layout
- Endianness of CPU
- Compiler behavior

---

# 9. Reentrancy and Nested Calls

Nested calls:

- Pass new ABI-encoded payload
- Maintain separate gas tracking
- Preserve call stack context

Return values must be fully decoded before state mutation.

---

# 10. Event Encoding

Events are encoded similarly:

EventLog = {
  contract_address,
  event_selector (8 bytes),
  event_data (ABI-encoded)
}

Events do not alter consensus state.

---

# 11. Error Codes

Standard error codes:

0x0001 = Unauthorized  
0x0002 = InvalidInput  
0x0003 = Overflow  
0x0004 = OutOfGas  
0x0005 = SelectorNotFound  

Error codes must be deterministic.

---

# 12. ABI Versioning

Each contract must declare:

abi_version: u16

Callers must match ABI version or risk revert.

Future versions may extend encoding but must preserve backward compatibility.

---

# 13. Security Considerations

TABI must prevent:

- Type confusion attacks
- Buffer overflow
- Malformed length prefix attacks
- Selector collision (8-byte truncation collision risk acceptable under SHA-256 assumptions)

Selector collision risk mitigated by:

- Contract-scoped resolution

---

# 14. Formal Encoding Function

Define:

Encode(type, value) → Bytes  
Decode(type, bytes) → value

Such that:

Decode(type, Encode(type, value)) = value

Must hold for all valid values.

---

# 15. Implementation Requirements

TVM implementations must:

- Reject non-canonical encodings
- Enforce exact byte lengths
- Validate UTF-8 correctness
- Enforce maximum bounds

Failure must revert deterministically.

---

# 16. Gas Accounting

Gas costs apply for:

- Calldata length
- Decoding operations
- Return data size

Costs must be fixed and governance-defined.

---

# 17. Example

Function:

fn transfer(to: Address, amount: u128)

Encoding:

selector (8 bytes)
+
Encode(Address)
+
Encode(u128)

---

# 18. Invariants

- ABI encoding deterministic
- No implicit type coercion
- No floating point
- Canonical field order
- Fixed-width integer encoding

---

# 19. Conclusion

TCL-201 defines TABI as:

- Canonical
- Deterministic
- Strongly typed
- Fixed-width encoded
- Selector-based

It guarantees that all contract invocations across the Tetcore network:

Produce identical decoding  
Produce identical execution  
Produce identical state transitions  

This ensures contract-level determinism within the Tetcore Virtual Machine.

---

End of TCL-201.