# IFP-105  
## Revenue Routing & Distribution Engine  
**Status:** Draft v1.0  
**Category:** Intelligence Fabric Protocol  

---

# 1. Purpose

This specification defines the deterministic revenue routing engine for inference settlements in the Intelligence Fabric Protocol (IFP).

It governs how fees collected from inference are distributed among:

- Inference operators  
- Model owners  
- Validators  
- Model vault participants  

All routing must be deterministic and value-conserving.

---

# 2. Revenue Input

Let:

F ∈ u128

Where:

F = final fee computed under IFP-104.

Constraint:

F ≤ escrow_amount

Revenue routing occurs immediately upon successful receipt validation.

---

# 3. Basis Point Model

Revenue splits are defined using basis points (bp).

1 basis point = 0.01%

Total basis points:

TOTAL_BP = 10,000

Each model defines:

RevenueSplit = {
  operator_bp: u16,
  owner_bp: u16,
  validator_bp: u16,
  vault_bp: u16
}

Constraint:

operator_bp + owner_bp + validator_bp + vault_bp = 10,000

Registration must reject invalid sums.

---

# 4. Share Computation

Given:

F = total fee

Compute shares in deterministic order:

1. operator_share = floor(F × operator_bp / 10,000)
2. owner_share = floor(F × owner_bp / 10,000)
3. validator_share = floor(F × validator_bp / 10,000)
4. vault_share = F - (operator_share + owner_share + validator_share)

This ensures:

Sum(shares) = F

No token loss or creation.

---

# 5. Operator Share

---

## 5.1 Definition

operator_share is transferred to:

operator_address

Specified in SubmitReceipt.

---

## 5.2 Validation

Operator must:

- Be valid account
- Be authorized to operate (if required)
- Have valid signature on receipt

If operator invalid:

Receipt rejected before routing.

---

# 6. Model Owner Share

---

## 6.1 Definition

owner_share is transferred to:

Model.owner

Defined in IFP-100.

---

## 6.2 Ownership Change Handling

If ownership transferred before receipt settlement:

Settlement must use owner at time of settlement.

---

# 7. Validator Share

---

## 7.1 Definition

validator_share is distributed among active validators.

Distribution model:

Equal split OR stake-weighted (governance-defined).

---

## 7.2 Equal Split Model (Default)

Let:

V = active validator set size

Each validator receives:

floor(validator_share / V)

Remainder assigned deterministically to:

Lowest lexicographic validator address.

---

## 7.3 Stake-Weighted Model (Optional)

Each validator has:

stake_weight

Share_i = floor(validator_share × weight_i / total_weight)

Remainder distributed deterministically.

Governance must specify model explicitly.

---

# 8. Vault Share

---

## 8.1 Definition

vault_share is routed to:

ModelVault associated with model_id

---

## 8.2 Vault Distribution

Vault maintains:

total_shares  
participant_shares[address]

For each participant:

participant_reward = floor(vault_share × participant_shares[address] / total_shares)

Remainder distributed to:

Largest share holder OR deterministic ordering.

---

## 8.3 Vault Disabled Case

If vault not enabled:

vault_share must be reassigned deterministically:

Option A (default): Add to owner_share  
Option B: Add to validator_share  

Policy must be defined in model metadata.

---

# 9. Deterministic Ordering Rules

All multi-recipient distributions must:

- Use canonical address ordering
- Avoid nondeterministic iteration
- Use fixed rounding rules

---

# 10. Escrow Finalization

After routing:

Escrow[prompt_tx_hash] must equal 0.

PromptEntry.status updated to:

SettledPendingChallenge

No further routing permitted.

---

# 11. Conservation Invariant

For every settlement:

operator_share
+ owner_share
+ validator_share
+ vault_share
= F

Total supply unchanged unless burn defined.

---

# 12. Optional Burn Mechanism

If governance enables burn:

Define:

burn_bp ∈ u16

Then:

burn_amount = floor(F × burn_bp / 10,000)

Remaining basis points adjusted proportionally.

Burned tokens permanently removed from supply.

Burn must be applied before revenue routing.

---

# 13. Rounding Determinism

All division uses:

Integer division (floor)

Final remainder always assigned to last category in sequence.

Sequence must be fixed and documented.

---

# 14. State Mutation

Routing modifies:

- Account balances
- Validator reward balances
- Vault reward balances
- Escrow ledger

All mutations must occur atomically.

---

# 15. Governance Modifications

Governance may:

- Set minimum or maximum basis points
- Enforce validator minimum share
- Modify burn parameters
- Change validator distribution model

Changes must not retroactively alter settled receipts.

---

# 16. Attack Resistance

Revenue routing must resist:

- Overflow attacks
- Rounding manipulation
- Zero-balance exploits
- Reentrancy (in contract-based routing)

Routing must execute before any external contract call.

---

# 17. Formal Routing Function

Define:

Route(F, RevenueSplit, ValidatorSet, VaultState) → State'

Where:

State' satisfies:

- Balances updated
- Escrow cleared
- Conservation preserved
- Deterministic rounding applied

---

# 18. Economic Implications

Revenue routing ensures:

- Operators incentivized to execute inference
- Model owners incentivized to publish models
- Validators incentivized to secure network
- Vault participants incentivized to stake

All incentives are derived from actual usage, not inflation.

---

# 19. Determinism Requirement

For identical:

- F
- RevenueSplit
- ValidatorSet
- VaultState

All nodes MUST compute identical:

Distribution outcomes.

---

# 20. Conclusion

IFP-105 defines:

- Basis point revenue splits
- Deterministic integer routing
- Multi-party distribution
- Escrow clearing
- Conservation invariants

It is the economic heart of the Intelligence Fabric Protocol.

All inference value flows through this engine.

---

End of IFP-105.