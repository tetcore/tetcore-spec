# IFP-106  
## Model Vault & Staking Protocol  
**Status:** Draft v1.0  
**Category:** Intelligence Fabric Protocol  

---

# 1. Purpose

This specification defines the Model Vault system of the Intelligence Fabric Protocol (IFP).

Model Vaults enable:

- Model-level staking
- Economic participation in model revenue
- Deterministic share issuance
- Proportional reward distribution
- Controlled withdrawal mechanics

Vault staking does NOT secure consensus.  
It is purely an economic participation mechanism.

---

# 2. Vault Definition

For each model_id, there MAY exist a ModelVault.

ModelVault = {
  model_id,
  total_staked: u128,
  total_shares: u128,
  participant_shares: Map<Address → u128>,
  pending_rewards: u128,
  withdrawal_delay: u64,
  status: {Enabled, Disabled}
}

---

# 3. Model-Level Staking

---

## 3.1 Stake Transaction

StakePayload:

{
  target_type = ModelVault,
  target_id = model_id,
  amount: u128
}

---

## 3.2 Validation Rules

Stake must:

- Reference existing model
- ModelVault.status == Enabled
- amount > 0
- sender balance ≥ amount

---

## 3.3 State Mutation

Upon staking:

1. Deduct amount from sender
2. Calculate shares to mint
3. Increase total_staked
4. Increase total_shares
5. Update participant_shares

---

# 4. Share Issuance

---

## 4.1 Share Model

Vault uses share-based accounting.

Initial state:

If total_shares == 0:

shares_minted = amount

Else:

shares_minted = floor(
  amount × total_shares / total_staked
)

---

## 4.2 Invariants

After minting:

total_shares_new = total_shares + shares_minted
total_staked_new = total_staked + amount

---

## 4.3 Precision Rules

All arithmetic must:

- Use u128
- Use floor division
- Avoid floating point

---

# 5. Revenue Accumulation

Revenue routed from IFP-105:

vault_share is added to:

pending_rewards

Vault does NOT automatically compound.

---

# 6. Revenue Proportionality

Participant reward:

reward_i = floor(
  pending_rewards × participant_shares[i] / total_shares
)

After distribution:

pending_rewards = 0

Alternatively, rewards may accumulate per share accounting model.

---

# 7. Reward Distribution Models

Two supported models:

---

## 7.1 Immediate Distribution

On receipt settlement:

Distribute vault_share immediately among participants.

---

## 7.2 Accumulated Distribution (Preferred)

Vault tracks:

reward_per_share_accumulator

On revenue addition:

reward_per_share += vault_share × SCALE / total_shares

Each participant tracks:

reward_debt

Claimable reward computed deterministically.

SCALE must be fixed constant.

---

# 8. Withdrawal Rules

---

## 8.1 Unstake Transaction

UnstakePayload:

{
  model_id,
  shares_to_burn: u128
}

---

## 8.2 Validation

- shares_to_burn ≤ participant_shares[sender]
- shares_to_burn > 0

---

## 8.3 Withdrawal Amount

withdraw_amount = floor(
  shares_to_burn × total_staked / total_shares
)

---

## 8.4 State Mutation

Upon unstake:

1. Burn shares
2. Decrease total_shares
3. Decrease total_staked
4. Record withdrawal request
5. Enforce withdrawal_delay

---

# 9. Withdrawal Delay

Vault may enforce:

withdrawal_delay ∈ u64 (blocks)

Funds become claimable after:

current_height ≥ request_height + withdrawal_delay

Delay protects against:

- Flash staking attacks
- Instant revenue extraction
- Economic manipulation

---

# 10. Vault Enable / Disable

Model owner may:

EnableVault  
DisableVault

If disabled:

- New staking rejected
- Existing stakes remain valid
- Withdrawals permitted

---

# 11. Vault Ownership & Control

Vault is governed by:

- Model owner
- Governance (if escalated)

Owner may:

- Set withdrawal_delay
- Enable/disable vault
- Modify future revenue split

Owner may NOT:

- Confiscate participant shares
- Retroactively alter share balances

---

# 12. Economic Properties

Vault staking allows:

- Passive exposure to model success
- Capital allocation to high-performing models
- Market-based valuation of intelligence assets

Vault does NOT:

- Guarantee yield
- Provide inflation-based rewards
- Secure consensus

---

# 13. Determinism Requirements

Vault operations must:

- Use integer arithmetic
- Apply canonical rounding
- Avoid nondeterministic iteration
- Produce identical state root across nodes

---

# 14. Edge Cases

---

## 14.1 Zero Stake Condition

If total_staked == 0:

No shares may be burned.

---

## 14.2 Last Share Burn

If total_shares becomes 0:

total_staked must also equal 0.

Invariant:

total_staked == 0 ⇔ total_shares == 0

---

# 15. Formal Definition

Stake:

(S, amount) → (S', shares_minted)

Unstake:

(S, shares) → (S', withdraw_amount)

Reward distribution:

pending_rewards → participant balances

All deterministic.

---

# 16. Governance Parameters

Governance may define:

- Minimum stake
- Maximum stake per address
- Withdrawal delay bounds
- Reward distribution model

Changes must not retroactively alter existing shares.

---

# 17. Security Considerations

Vault must prevent:

- Share inflation attacks
- Rounding exploitation
- Flash deposit exploitation
- Reentrancy during routing

Vault distribution must execute before external contract calls.

---

# 18. Economic Invariants

At all times:

Σ participant_shares = total_shares

total_staked ≥ 0

pending_rewards ≥ 0

No share may exist without backing stake.

---

# 19. Interaction with IFP-105

vault_share from revenue routing:

→ Added to vault accounting  
→ Distributed per share rules  

Vault does not intercept routing logic.

---

# 20. Conclusion

IFP-106 defines:

- Deterministic model-level staking
- Share-based participation
- Proportional revenue distribution
- Controlled withdrawal mechanics
- Governance-compatible economics

It transforms models into investable, stakeable intelligence assets.

This completes the economic participation layer of the Intelligence Fabric Protocol.

---

End of IFP-106.